1. a) Компилируемые языки. Код с помощью специальной программы (компилятора) преобразуется (компилируется) в машинный
   код и записывается в исполняемый файл, который может быть запущен на выполнение как отдельная программа.

-    ***Проще говоря - перевод языка с высокого уровня на низкий.***


 -   **Плюсы**: выполняются быстро, не требуют дополнительных программ.
     

  - **Минусы**: при любых изменениях требуется перекомпиляция; скомпилированная программа может выполняться только на том
   же типе компьютеров, под которую рассчитан компилятор. Если, к примеру, другая ОС - требуется новая компиляция
   
   
   b) Если программа написана на интерпретируемом языке, то интерпретатор непосредственно выполняет (интерпретирует) ее
   текст без предварительного перевода.
   
   
   При этом программа остается на исходном языке и не может быть запущена без интерпретатора. Можно сказать, что
   процессор компьютера — это интерпретатор машинного кода.
   
   
   Кратко говоря, интерпретатор переводит на машинный язык прямо во время исполнения программы.
   
   
   Программы на интерпретируемых языках можно запускать сразу же после изменения, что облегчает разработку.
   
   
   Программа на интерпретируемом языке может быть зачастую запущена на разных типах машин и операционных систем без
   дополнительных усилий.
   
   
   Однако интерпретируемые программы выполняются заметно медленнее, чем компилируемые, кроме того, они не могут
   выполняться без дополнительной программы-интерпретатора.

2. Отрицательные числа (int) в Java хранятся в следующем виде:
   ```java
   0000 0111 = 7 (положительное)
   1111 1001 = -7 (отрицательное, бинарное представление как бы инвертируется)
   /* Почему в конце 1001? */
   // Потому что: -7 = 1001= -8 + 0 + 0 + 1 
   
   Как найти бинарное представление отрицательного числа?
   1) Конвертируем в двоичный код положительное число: 4 = 0100
   2) Инвертируем все биты: 0100 -> 1011
   3) Добавляем один бит: 1011 + 1 = 1100 = -4
   
   -3 byte в бинарном виде: 11111101
   ```
3. Тернарный оператор (```? *если true* : *если false*```) является альтернативой if-else. Если не подразумевается
   использование else, тогда тернарное условие не подойдет
4. Пример сложности по времени O(n^2) и по памяти O(n):
   ```java
     public int sumArray(int[] array) {
       int size = array.length;
       int sum = 0;

       for (int i = 0; i < size; i++) {
          for (int j = 0; i < size; j++) { // Тут Time(O(n^2))
           sum += array[j]; // Тут Space(O(n))
          }
       }

       return sum;
   }
   ```

5. Массив - упорядоченный набор однотипных элементов. Сколько действий требуется, чтобы обратиться к элементу? Одно. Мы
   явно указываем индекс для обращения, например ```ar[2]```
   
   *Адрес указывается непосредственно в виде некоторого значения, все ячейки располагаются на одной странице.
   Преимущество этого способа в том, что он самый простой, а недостаток — в том, что разрядность регистров общего
   назначения процессора должна быть не меньше разрядности шины адреса процессора. (Wiki)*
   
   ***Честно говоря, хз как это объяснить))***


6. Да, всегда.
   ```java
   // ----- Рекурсивный -----
   static int factorialUsingRecursion(int n)
    {
        if (n == 0)
            return 1;
         
        return n * factorialUsingRecursion(n - 1);
    }
  
    // ----- Итеративный -----
    static int factorialUsingIteration(int n)
    {
        int res = 1, i;
         
        for (i = 2; i <= n; i++)
            res *= i;
  
        return res;
    }
   ```
7. Модификатор *private* позволяет ограничить видимость поля/метода. Иерархия следующая (по убыванию):
    1. public (везде)
    2. protected (внутри папки {пакета} + у дочерних классов {даже если в другом пакете})
    3. default (только внутри пакета)
    4. private (внутри класса)


8. Интерфейсы в отличие от классов имплементируются (implements). Говоря о классах - запрещено множественное
   наследование (по причине того, что будь два родительских класса с одинаковой сигнатурой метода - неясно что из этого
   использовать)
   ```java
   public class Binocla implements Sum, AnotherSum {
       public static void main(String[] args) {
          Binocla b = new Binocla();
          System.out.println(b.sum(2, 5));
      }

      @Override
      public int sum(int x, int y) {
          return x + y;
      }
   }
       
   interface Sum {
    int sum(int x, int y);
   }

   interface AnotherSum {
    int sum(int x, int y);
   }
   ```